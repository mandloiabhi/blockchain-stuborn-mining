Simulation of a P2P Cryptocurrency Network


Compiling and running the code :
1. python3 main.py <Number of nodes> <Ttx (TXN Interarrival mean time)> <percent of slow nodes> <percent of low CPU nodes>

2. The program will run for 30 sec. After the code runs successfully, the blockchain tree for each node will be displayed and will be saved in a png file. Also, the longest chain for each node will be displayed and will be saved in a png file.

3. Also, a txt file will be created for each node which contains the block ids and its corresponding arrival time of each block present in that node's blockchain tree.


Files:
1. main.py: This file will take the required command line inputs. Then it will create a randomly connected graph between 4 and 8 other peers from n nodes by taking help from generate_graph.py. Then, it will initiate the initial TXN and initial block generation event. It will then pop events one by one from the events queue, and based on the event type, it will do the processing. There will be 4 types of events: TXN_GEN, TXN_REC, BLK_GEN, and BLK_REC. Then, after all the processing, it will display the blockchain tree and longest chain for each node.

2. node.py: This file contains various properties and data structures required by the node. This also includes functions for TXN Generation, TXN Receive, BLK Generation and BLK Receive.

3. generate_graph.py: It will create a randomly connected graph to between 4 and 8 other peers from n nodes

4. transaction_object.py: This file contains the parameters required for a transaction object.

5. block.py:  This file contains the parameters required for a block object.

6. event.py: This file contains the parameters required for an Event object.

7. global_data.py: This file contains the global parameters that can be required by many other files.

Build my own discrete-event simulator for a P2P cryptocurrency network. A discrete-event simulator maintains an
”event-queue” from which the earliest event is executed. This event may create further future events which get
added to the queue. For example, an event in which one node ”sends a block” to connected peers will create
future events of ”receive block” at its peers.

The cryptocurrency network has the following properties (note that all IDs mentioned below must be
unique).
1. There are n peers, each with a unique ID, where n is set at the time of initiation of the network. Some of
these nodes (say z 0 percent, where z 0 is a command line simulation parameter) are labeled “slow” and the others
“fast”. In addition, some of these nodes (say z 1 percent, where z 1 is a command line simulation parameter) are
labeled “low CPU” and the others “high CPU”. We will use this classification below.

3. Each peer generates transactions randomly in time. The interarrival between transactions generated by
any peer is chosen from an exponential distribution whose mean time(T tx ) can be set as a parameter of the
simulator.

4. Each transaction has the format: “TxnID: ID x pays ID y C coins”. You must ensure that C is less than
or equal to the coins currently owned by ID x (ID of the peer generating the transaction) before including it in
a block. ID y should be the ID of any other peer in the network where transaction is destined. The size of each
transaction is assumed to be 1 KB.

6. (Network topology) Each peer is randomly connected to between 4 and 8 other peers.

7. Simulate latencies L ij between pairs of peers i and j connected by a link. Latency is the time between
which a message m was transmitted from sender i and received by another node j. Choose the latency to be of
the form ρ ij + |m|/c ij + d ij , where ρ ij is a positive minimum value corresponding to speed of light propagation
delay, |m| denotes the length of the message in bits, c ij is the link speed between i and j in bits per second, and
d ij is the queuing delay at node i to forward the message to node j. d ij is randomly chosen from an exponential
distribution with some mean 96kbits/c i,j . Note that d i,j must be randomly chosen for each message transmitted
from i to j. ρ ij can be chosen from a uniform distribution between 10ms and 500ms at the start of the simulation.
c ij is set to 100 Mbps if both i and j are fast, and 5 Mbps if either of the nodes is slow.


16. A node forwards any transaction heard from one peer to another connected peer, provided it has not
already sent the same transaction to that peer, or provided it did not hear (receive) the transaction from that
peer.

7. Simulating PoW: All nodes have the genesis block at the start of the simulation. Each block must have
a unique ID, say BlkID (You can choose any method to ensure this). Any peer, say peer k, maintains a tree of
blocks as in bitcoin. When it receives a block from another peer, it validates all its transactions (no balance of
any peer should go negative), and if the block is valid it adds the block to its tree.
When a received block creates a new longest chain at peer k (longer than the previous longest chain), say
at time t k , then we simulate PoW mining of a new block as follows. Peer k forms a block at t k by selecting a
subset of the transactions received so far and not included in any blocks in the longest chain. After forming a
block, node k generates a random variable T k , at time t k , as follows.
Suppose the interarrival time between blocks on average is I (for example, I is 600 sec in Bitcoin), and
node k has fraction h k (where 0 < h k < 1) of the total hashing power. Then T k is drawn from an exponential
distribution with mean equal to I/h k . If peer k is a high CPU P
node, then it is assumed to have 10 times higher
hashing power than a low CPU node.

If peer k has the same longest chain at time t k + T k then it broadcasts a new block. (If it no longer has
the same longest chain at t k + T k then the event scheduled for mining a block at t k + T k is terminated.) This
block lists the BlkID of the previous block in the longest chain it has received so far and the list of transactions
included in it. Once broadcast, the node starts creating the new block. The block is assumed to contribute
50 coins to k (i.e. ID k ) as a mining fee, and this is included as a coinbase transaction ”TxnID:ID k mines
50 coins”. On the contrary, if node k receives the block from another node in the network, it validates all its
transactions. Valid transactions are those where the sender has sufficient balance to perform the transaction.
After validation, the node again starts block creation, as explained above.
The block propagates in the network just like individual transactions. A block can have size at max 1 MB
(8 × 10 6 bits) and actual size depends on the number of transactions encapsulated in the block. An empty block
(with no transactions besides the coinbase) is assumed to be of size 1KB. Ensure that you do not have too
many transactions in the block such that the size of the block exceeds the maximum permitted size.

9. Each node maintains a tree of all blockchains heard since the start of the simulation. The node stores
the time of arrival of every block in its tree. This information is written to a file at the end of the simulation.

Used  visualization tool to study the blockchain tree . Experiment with choosing different values for different parameters (n, z, T tx ,
T d ij , mean of T k , etc.).Found the ratio of the number of blocks generated by each node in the Longest Chain
of the tree to the total number of blocks it generates at the end of the simulation. How does this ratio vary
depending on whether the node is fast, slow, low CPU, high CPU power etc.? How long are branches of the
tree measured in number of blocks? Give detailed insights to explain your observations.
